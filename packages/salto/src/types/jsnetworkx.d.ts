/** Declaration file generated by dts-gen */

export class DiGraph {
    constructor(optData: any, optAttr: any);

    addEdge(u: any, v: any, ...args: any[]): void;

    addEdgesFrom(ebunch: any, ...args: any[]): void;

    addNode(n: any, ...args: any[]): void;

    addNodesFrom(nodes: any, ...args: any[]): void;

    clear(): void;

    degreeIter(optNbunch: any, optWeight: any): any;

    edgesIter(optNbunch: any, ...args: any[]): any;

    hasPredecessor(u: any, v: any): any;

    hasSuccessor(u: any, v: any): any;

    inDegree(optNbunch: any, optWeight: any): any;

    inDegreeIter(optNbunch: any, optWeight: any): any;

    inEdges(optNbunch: any, ...args: any[]): any;

    inEdgesIter(optNbunch: any, ...args: any[]): any;

    isDirected(): any;

    isMultigraph(): any;

    neighbors(n: any): any;

    neighborsIter(n: any): any;

    outDegree(optNbunch: any, optWeight: any): any;

    outDegreeIter(optNbunch: any, optWeight: any): any;

    outEdges(optNbunch: any, optData: any): any;

    outEdgesIter(optNbunch: any, optData: any): any;

    predecessors(n: any): any;

    predecessorsIter(n: any): any;

    removeEdge(u: any, v: any): void;

    removeEdgesFrom(ebunch: any): void;

    removeNode(n: any): void;

    removeNodesFrom(nodes: any): void;

    reverse(...args: any[]): any;

    subgraph(nbunch: any): any;

    successors(n: any): any;

    successorsIter(n: any): any;

    toDirected(): any;

    toUndirected(optReciprocal: any): any;

}

export class Graph {
    constructor(optData: any, optAttr: any);

    addCycle(nodes: any, optAttr: any): void;

    addEdge(u: any, v: any, optAttrDict: any): void;

    addEdgesFrom(ebunch: any, optAttrDict: any): void;

    addNode(n: any, ...args: any[]): void;

    addNodesFrom(nodes: any, ...args: any[]): void;

    addPath(nodes: any, optAttr: any): void;

    addStar(nodes: any, optAttr: any): any;

    addWeightedEdgesFrom(ebunch: any, optWeight: any, optAttr: any): any;

    adjacencyIter(): any;

    adjacencyList(): any;

    clear(): void;

    copy(): any;

    degree(optNbunch: any, optWeight: any): any;

    degreeIter(optNbunch: any, optWeight: any): any;

    edges(optNbunch: any, ...args: any[]): any;

    edgesIter(optNbunch: any, ...args: any[]): any;

    get(n: any): any;

    getEdgeData(u: any, v: any, ...args: any[]): any;

    hasEdge(u: any, v: any): any;

    hasNode(n: any): any;

    isDirected(): any;

    isMultigraph(): any;

    nbunchIter(optNbunch: any): any;

    neighbors(n: any): any;

    neighborsIter(n: any): any;

    nodes(...args: any[]): any;

    nodesIter(...args: any[]): any;

    nodesWithSelfloops(): any;

    numberOfEdges(u: any, v: any): any;

    numberOfNodes(): any;

    numberOfSelfloops(): any;

    order(): any;

    removeEdge(u: any, v: any): void;

    removeEdgesFrom(ebunch: any): void;

    removeNode(n: any): any;

    removeNodesFrom(nodes: any): any;

    selfloopEdges(...args: any[]): any;

    size(optWeight: any): any;

    subgraph(nbunch: any): any;

    toDirected(): any;

    toString(): any;

    toUndirected(): any;

}

export class Map {
    constructor(optData: any);

    clear(): void;

    delete(key: any): any;

    entries(): any;

    forEach(callback: any, optThis: any): void;

    get(key: any, optDefaultValue: any): any;

    has(key: any): any;

    keys(): any;

    set(key: any, value: any): any;

    values(): any;

}

export class MultiDiGraph {
    constructor(optData: any, optAttr: any);

    addEdge(u: any, v: any, optKey: any, optAttrDict: any): void;

    addEdgesFrom(ebunch: any, optAttrDict: any): void;

    degreeIter(optNbunch: any, optWeight: any): any;

    edges(optNbunch: any, optData: any, optKeys: any): any;

    edgesIter(optNbunch: any, ...args: any[]): any;

    getEdgeData(u: any, v: any, optKey: any, optDefault: any): any;

    hasEdge(u: any, v: any, optKey: any): any;

    inDegreeIter(optNbunch: any, optWeight: any): any;

    inEdges(optNbunch: any, optData: any, optKeys: any): any;

    inEdgesIter(optNbunch: any, ...args: any[]): any;

    isDirected(): any;

    isMultigraph(): any;

    numberOfEdges(optU: any, optV: any): any;

    outDegreeIter(optNbunch: any, optWeight: any): any;

    outEdges(optNbunch: any, optData: any, optKeys: any): any;

    outEdgesIter(optNbunch: any, optData: any, optKeys: any): any;

    removeEdge(u: any, v: any, optKey: any): void;

    removeEdgesFrom(ebunch: any): void;

    reverse(...args: any[]): any;

    selfloopEdges(...args: any[]): any;

    subgraph(nBunch: any): any;

    toDirected(): any;

    toUndirected(optReciprocal: any): any;

}

export class MultiGraph {
    constructor(optData: any, optAttr: any);

    addEdge(u: any, v: any, optKey: any, optAttrDict: any): void;

    addEdgesFrom(ebunch: any, optAttrDict: any): void;

    degreeIter(optNbunch: any, optWeight: any): any;

    edges(optNbunch: any, optData: any, optKeys: any): any;

    edgesIter(optNbunch: any, ...args: any[]): any;

    getEdgeData(u: any, v: any, optKey: any, optDefault: any): any;

    hasEdge(u: any, v: any, optKey: any): any;

    isDirected(): any;

    isMultigraph(): any;

    numberOfEdges(optU: any, optV: any): any;

    removeEdge(u: any, v: any, optKey: any): void;

    removeEdgesFrom(ebunch: any): void;

    selfloopEdges(...args: any[]): any;

    subgraph(nbunch: any): any;

    toDirected(): any;

}

export class Set {
    constructor(optData: any);

    add(value: any): void;

    clear(): void;

    delete(value: any): any;

    difference(...args: any[]): any;

    entries(): any;

    forEach(callback: any, optThis: any): void;

    has(value: any): any;

    intersection(...args: any[]): any;

    keys(): any;

    pop(): any;

    values(): any;

}

export const svg: any;

export function JSNetworkXAlgorithmError(message: any): void;

export function JSNetworkXError(message: any): void;

export function JSNetworkXException(message: any): void;

export function JSNetworkXNoPath(message: any): void;

export function JSNetworkXUnfeasible(message: any): void;

export function KeyError(message: any): void;

export function allPairsDijkstraPath(G: any, ...args: any[]): any;

export function allPairsDijkstraPathLength(G: any, ...args: any[]): any;

export function allPairsShortestPath(G: any, optCutoff: any): any;

export function allPairsShortestPathLength(G: any, optCutoff: any): any;

export function averageClustering(G: any, optNodes: any, optWeight: any, ...args: any[]): any;

export function balancedTree(r: any, h: any, optCreateUsing: any): any;

export function betweennessCentrality(G: any, ...args: any[]): any;

export function bidirectionalShortestPath(G: any, source: any, target: any): any;

export function binomialGraph(n: any, p: any, optDirected: any): any;

export function bullGraph(optCreateUsing: any): any;

export function clustering(G: any, optNodes: any, optWeight: any): any;

export function completeGraph(n: any, optCreateUsing: any): any;

export function compose(G: any, H: any): any;

export function convertNodeLabelsToIntegers(G: any, ...args: any[]): any;

export function convertToDirected(G: any): any;

export function convertToUndirected(G: any): any;

export function couldBeIsomorphic(G1: any, G2: any): any;

export function createEmptyCopy(G: any, ...args: any[]): any;

export function cycleGraph(n: any, optCreateUsing: any): any;

export function davisSouthernWomenGraph(): any;

export function degree(G: any, optNbunch: any, optWeight: any): any;

export function degreeHistogram(G: any): any;

export function density(G: any): any;

export function difference(G: any, H: any): any;

export function dijkstraPath(G: any, _ref3: any): any;

export function dijkstraPathLength(G: any, _ref4: any): any;

export function disjointUnion(G: any, H: any): any;

export function draw(G: any, config: any, optBind: any): any;

export function edgeBetweennessCentrality(G: any, ...args: any[]): any;

export function edges(G: any, optNbunch: any): any;

export function edgesIter(G: any, optNbunch: any): any;

export function eigenvectorCentrality(G: any, ...args: any[]): any;

export function emptyGraph(optN: any, optCreateUsing: any): any;

export function erdosRenyiGraph(n: any, p: any, optDirected: any): any;

export function fastCouldBeIsomorphic(G1: any, G2: any): any;

export function fastGnpRandomGraph(n: any, p: any, ...args: any[]): any;

export function fasterCouldBeIsomorphic(G1: any, G2: any): any;

export function findCliques(G: any): any;

export function findCliquesRecursive(G: any): any;

export function florentineFamiliesGraph(): any;

export function forEach(seq: any, callback: any, optThisObj: any): void;

export function freeze(G: any): any;

export function fromDictOfDicts(d: any, optCreateUsing: any, ...args: any[]): any;

export function fromDictOfLists(d: any, optCreateUsing: any): any;

export function fromEdgelist(edgelist: any, optCreateUsing: any): any;

export function fullRaryTree(r: any, n: any, optCreateUsing: any): any;

export function genAllPairsDijkstraPath(G: any, _cutoff$weight2: any): any;

export function genAllPairsDijkstraPathLength(G: any, _cutoff$weight: any): any;

export function genAllPairsShortestPath(G: any, optCutoff: any): any;

export function genAllPairsShortestPathLength(G: any, optCutoff: any): any;

export function genAverageClustering(G: any, optNodes: any, optWeight: any, optCountZeros: any): any;

export function genBetweennessCentrality(G: any, optArgDict: any): any;

export function genBidirectionalShortestPath(G: any, source: any, target: any): any;

export function genBinomialGraph(n: any, p: any, optDirected: any): any;

export function genClustering(G: any, optNodes: any, optWeight: any): any;

export function genCompose(G: any, H: any): any;

export function genCouldBeIsomorphic(G1: any, G2: any): any;

export function genDifference(G: any, H: any): any;

export function genDijkstraPath(G: any, _source$target$weight: any): any;

export function genDijkstraPathLength(G: any, _source$target$weight2: any): any;

export function genDisjointUnion(G: any, H: any): any;

export function genEdgeBetweennessCentrality(G: any, optArgDict: any): any;

export function genEigenvectorCentrality(G: any, _maxIter$tolerance$nstart$weight: any): any;

export function genErdosRenyiGraph(n: any, p: any, optDirected: any): any;

export function genFastCouldBeIsomorphic(G1: any, G2: any): any;

export function genFastGnpRandomGraph(n: any, p: any, optDirected: any): any;

export function genFasterCouldBeIsomorphic(G1: any, G2: any): any;

export function genFindCliques(G: any): any;

export function genFindCliquesRecursive(G: any): any;

export function genGnpRandomGraph(n: any, p: any, optDirected: any): any;

export function genGraphCliqueNumber(G: any, optCliques: any): any;

export function genGraphNumberOfCliques(G: any, optCliques: any): any;

export function genHasPath(G: any, _source$target: any): any;

export function genHavelHakimiGraph(degreeSequence: any, optCreateUsing: any): any;

export function genIntersection(G: any, H: any): any;

export function genIsAperiodic(G: any): any;

export function genIsDirectedAcyclicGraph(G: any): any;

export function genIsGraphical(sequence: any, optMethod: any): any;

export function genIsValidDegreeSequence(sequence: any, optMethod: any): any;

export function genIsValidDegreeSequenceErdosGallai(degreeSequence: any): any;

export function genIsValidDegreeSequenceHavelHakimi(degreeSequence: any): any;

export function genNumberOfCliques(G: any, optNodes: any, optCliques: any): any;

export function genPredecessor(G: any, source: any, optArgs: any): any;

export function genShortestPath(G: any, _source$target$weight: any): any;

export function genShortestPathLength(G: any, _source$target$weight2: any): any;

export function genSingleSourceDijkstra(G: any, _source$target$cutoff$weight: any): any;

export function genSingleSourceDijkstraPath(G: any, _source$cutoff$weight: any): any;

export function genSingleSourceDijkstraPathLength(G: any, _source$cutoff$weight2: any): any;

export function genSingleSourceShortestPath(G: any, source: any, optCutoff: any): any;

export function genSingleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

export function genSquareClustering(G: any, optNodes: any): any;

export function genSymmetricDifference(G: any, H: any): any;

export function genTopologicalSort(G: any, optNbunch: any): any;

export function genTopologicalSortRecursive(G: any, optNbunch: any): any;

export function genTransitivity(G: any): any;

export function genTriangles(G: any, optNodes: any): any;

export function genUnion(G: any, H: any, _rename: any): any;

export function getEdgeAttributes(G: any, name: any): any;

export function getNodeAttributes(G: any, name: any): any;

export function gnpRandomGraph(n: any, p: any, ...args: any[]): any;

export function graphCliqueNumber(G: any, optCliques: any): any;

export function graphNumberOfCliques(G: any, optCliques: any): any;

export function grid2dGraph(rows: any, columns: any, ...args: any[]): any;

export function hasPath(G: any, _ref: any): any;

export function havelHakimiGraph(degreeSequence: any, optCreateUsing: any): any;

export function info(G: any, optN: any): any;

export function intersection(G: any, H: any): any;

export function isAperiodic(_x: any): any;

export function isDirected(G: any): any;

export function isDirectedAcyclicGraph(G: any): any;

export function isFrozen(G: any): any;

export function isGraphical(sequence: any, ...args: any[]): any;

export function isObservable(G: any): any;

export function isValidDegreeSequence(sequence: any, optMethod: any): any;

export function isValidDegreeSequenceErdosGallai(degreeSequence: any): any;

export function isValidDegreeSequenceHavelHakimi(degreeSequence: any): any;

export function karateClubGraph(): any;

export function krackhardtKiteGraph(optCreateUsing: any): any;

export function makeSmallGraph(_ref: any, optCreateUsing: any): any;

export function makeSmallUndirectedGraph(graphDescription: any, optCreateUsing: any): any;

export function neighbors(G: any, n: any): any;

export function nodes(G: any): any;

export function nodesIter(G: any): any;

export function nullGraph(optCreateUsing: any): any;

export function numberOfCliques(G: any, optNodes: any, optCliques: any): any;

export function numberOfEdges(G: any): any;

export function numberOfNodes(G: any): any;

export function observe(G: any, ...args: any[]): any;

export function pathGraph(n: any, optCreateUsing: any): any;

export function predecessor(G: any, source: any, ...args: any[]): any;

export function relabelNodes(G: any, mapping: any, ...args: any[]): any;

export function setEdgeAttributes(G: any, name: any, attributes: any): void;

export function setNodeAttributes(G: any, name: any, attributes: any): any;

export function shortestPath(G: any, ...args: any[]): any;

export function shortestPathLength(G: any, ...args: any[]): any;

export function singleSourceDijkstra(G: any, _ref8: any): any;

export function singleSourceDijkstraPath(G: any, _ref5: any): any;

export function singleSourceDijkstraPathLength(G: any, _ref6: any): any;

export function singleSourceShortestPath(G: any, source: any, optCutoff: any): any;

export function singleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

export function squareClustering(G: any, optNodes: any): any;

export function subgraph(G: any, nbunch: any): any;

export function symmetricDifference(G: any, H: any): any;

export function toArray(p0: any): any;

export function toDictOfDicts(G: any, optNodelist: any, optEdgeData: any): any;

export function toDictOfLists(G: any, optNodelist: any): any;

export function toEdgelist(G: any, optNodelist: any): any;

export function toNetworkxGraph(data: any, optCreateUsing: any, ...args: any[]): any;

export function topologicalSort(G: any, optNbunch: any): any;

export function topologicalSortRecursive(G: any, optNbunch: any): any;

export function transitivity(G: any): any;

export function triangles(G: any, optNodes: any): any;

export function trivialGraph(optCreateUsing: any): any;

export function union(G: any, H: any, ...args: any[]): any;

export function unobserve(G: any): any;

export namespace KeyError {
    const stackTraceLimit: number;

    function captureStackTrace(p0: any, p1: any): any;

}

export namespace algorithms {
    function allPairsDijkstraPath(G: any, ...args: any[]): any;

    function allPairsDijkstraPathLength(G: any, ...args: any[]): any;

    function allPairsShortestPath(G: any, optCutoff: any): any;

    function allPairsShortestPathLength(G: any, optCutoff: any): any;

    function averageClustering(G: any, optNodes: any, optWeight: any, ...args: any[]): any;

    function betweennessCentrality(G: any, ...args: any[]): any;

    function bidirectionalShortestPath(G: any, source: any, target: any): any;

    function clustering(G: any, optNodes: any, optWeight: any): any;

    function compose(G: any, H: any): any;

    function couldBeIsomorphic(G1: any, G2: any): any;

    function difference(G: any, H: any): any;

    function dijkstraPath(G: any, _ref3: any): any;

    function dijkstraPathLength(G: any, _ref4: any): any;

    function disjointUnion(G: any, H: any): any;

    function edgeBetweennessCentrality(G: any, ...args: any[]): any;

    function eigenvectorCentrality(G: any, ...args: any[]): any;

    function fastCouldBeIsomorphic(G1: any, G2: any): any;

    function fasterCouldBeIsomorphic(G1: any, G2: any): any;

    function findCliques(G: any): any;

    function findCliquesRecursive(G: any): any;

    function genAllPairsDijkstraPath(G: any, _cutoff$weight2: any): any;

    function genAllPairsDijkstraPathLength(G: any, _cutoff$weight: any): any;

    function genAllPairsShortestPath(G: any, optCutoff: any): any;

    function genAllPairsShortestPathLength(G: any, optCutoff: any): any;

    function genAverageClustering(G: any, optNodes: any, optWeight: any, optCountZeros: any): any;

    function genBetweennessCentrality(G: any, optArgDict: any): any;

    function genBidirectionalShortestPath(G: any, source: any, target: any): any;

    function genClustering(G: any, optNodes: any, optWeight: any): any;

    function genCompose(G: any, H: any): any;

    function genCouldBeIsomorphic(G1: any, G2: any): any;

    function genDifference(G: any, H: any): any;

    function genDijkstraPath(G: any, _source$target$weight: any): any;

    function genDijkstraPathLength(G: any, _source$target$weight2: any): any;

    function genDisjointUnion(G: any, H: any): any;

    function genEdgeBetweennessCentrality(G: any, optArgDict: any): any;

    function genEigenvectorCentrality(G: any, _maxIter$tolerance$nstart$weight: any): any;

    function genFastCouldBeIsomorphic(G1: any, G2: any): any;

    function genFasterCouldBeIsomorphic(G1: any, G2: any): any;

    function genFindCliques(G: any): any;

    function genFindCliquesRecursive(G: any): any;

    function genGraphCliqueNumber(G: any, optCliques: any): any;

    function genGraphNumberOfCliques(G: any, optCliques: any): any;

    function genHasPath(G: any, _source$target: any): any;

    function genIntersection(G: any, H: any): any;

    function genIsAperiodic(G: any): any;

    function genIsDirectedAcyclicGraph(G: any): any;

    function genIsGraphical(sequence: any, optMethod: any): any;

    function genIsValidDegreeSequence(sequence: any, optMethod: any): any;

    function genIsValidDegreeSequenceErdosGallai(degreeSequence: any): any;

    function genIsValidDegreeSequenceHavelHakimi(degreeSequence: any): any;

    function genNumberOfCliques(G: any, optNodes: any, optCliques: any): any;

    function genPredecessor(G: any, source: any, optArgs: any): any;

    function genShortestPath(G: any, _source$target$weight: any): any;

    function genShortestPathLength(G: any, _source$target$weight2: any): any;

    function genSingleSourceDijkstra(G: any, _source$target$cutoff$weight: any): any;

    function genSingleSourceDijkstraPath(G: any, _source$cutoff$weight: any): any;

    function genSingleSourceDijkstraPathLength(G: any, _source$cutoff$weight2: any): any;

    function genSingleSourceShortestPath(G: any, source: any, optCutoff: any): any;

    function genSingleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

    function genSquareClustering(G: any, optNodes: any): any;

    function genSymmetricDifference(G: any, H: any): any;

    function genTopologicalSort(G: any, optNbunch: any): any;

    function genTopologicalSortRecursive(G: any, optNbunch: any): any;

    function genTransitivity(G: any): any;

    function genTriangles(G: any, optNodes: any): any;

    function genUnion(G: any, H: any, _rename: any): any;

    function graphCliqueNumber(G: any, optCliques: any): any;

    function graphNumberOfCliques(G: any, optCliques: any): any;

    function hasPath(G: any, _ref: any): any;

    function intersection(G: any, H: any): any;

    function isAperiodic(_x: any): any;

    function isDirectedAcyclicGraph(G: any): any;

    function isGraphical(sequence: any, ...args: any[]): any;

    function isValidDegreeSequence(sequence: any, optMethod: any): any;

    function isValidDegreeSequenceErdosGallai(degreeSequence: any): any;

    function isValidDegreeSequenceHavelHakimi(degreeSequence: any): any;

    function numberOfCliques(G: any, optNodes: any, optCliques: any): any;

    function predecessor(G: any, source: any, ...args: any[]): any;

    function shortestPath(G: any, ...args: any[]): any;

    function shortestPathLength(G: any, ...args: any[]): any;

    function singleSourceDijkstra(G: any, _ref8: any): any;

    function singleSourceDijkstraPath(G: any, _ref5: any): any;

    function singleSourceDijkstraPathLength(G: any, _ref6: any): any;

    function singleSourceShortestPath(G: any, source: any, optCutoff: any): any;

    function singleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

    function squareClustering(G: any, optNodes: any): any;

    function symmetricDifference(G: any, H: any): any;

    function topologicalSort(G: any, optNbunch: any): any;

    function topologicalSortRecursive(G: any, optNbunch: any): any;

    function transitivity(G: any): any;

    function triangles(G: any, optNodes: any): any;

    function union(G: any, H: any, ...args: any[]): any;

    namespace betweenness {
        function betweennessCentrality(G: any, ...args: any[]): any;

        function edgeBetweennessCentrality(G: any, ...args: any[]): any;

        function genBetweennessCentrality(G: any, optArgDict: any): any;

        function genEdgeBetweennessCentrality(G: any, optArgDict: any): any;

    }

    namespace binary {
        function compose(G: any, H: any): any;

        function difference(G: any, H: any): any;

        function disjointUnion(G: any, H: any): any;

        function genCompose(G: any, H: any): any;

        function genDifference(G: any, H: any): any;

        function genDisjointUnion(G: any, H: any): any;

        function genIntersection(G: any, H: any): any;

        function genSymmetricDifference(G: any, H: any): any;

        function genUnion(G: any, H: any, _rename: any): any;

        function intersection(G: any, H: any): any;

        function symmetricDifference(G: any, H: any): any;

        function union(G: any, H: any, ...args: any[]): any;

    }

    namespace centrality {
        function betweennessCentrality(G: any, ...args: any[]): any;

        function edgeBetweennessCentrality(G: any, ...args: any[]): any;

        function eigenvectorCentrality(G: any, ...args: any[]): any;

        function genBetweennessCentrality(G: any, optArgDict: any): any;

        function genEdgeBetweennessCentrality(G: any, optArgDict: any): any;

        function genEigenvectorCentrality(G: any, _maxIter$tolerance$nstart$weight: any): any;

        namespace betweenness {
            function betweennessCentrality(G: any, ...args: any[]): any;

            function edgeBetweennessCentrality(G: any, ...args: any[]): any;

            function genBetweennessCentrality(G: any, optArgDict: any): any;

            function genEdgeBetweennessCentrality(G: any, optArgDict: any): any;

        }

        namespace eigenvector {
            function eigenvectorCentrality(G: any, ...args: any[]): any;

            function genEigenvectorCentrality(G: any, _maxIter$tolerance$nstart$weight: any): any;

        }

    }

    namespace clique {
        function findCliques(G: any): any;

        function findCliquesRecursive(G: any): any;

        function genFindCliques(G: any): any;

        function genFindCliquesRecursive(G: any): any;

        function genGraphCliqueNumber(G: any, optCliques: any): any;

        function genGraphNumberOfCliques(G: any, optCliques: any): any;

        function genNumberOfCliques(G: any, optNodes: any, optCliques: any): any;

        function graphCliqueNumber(G: any, optCliques: any): any;

        function graphNumberOfCliques(G: any, optCliques: any): any;

        function numberOfCliques(G: any, optNodes: any, optCliques: any): any;

    }

    namespace cluster {
        function averageClustering(G: any, optNodes: any, optWeight: any, ...args: any[]): any;

        function clustering(G: any, optNodes: any, optWeight: any): any;

        function genAverageClustering(G: any, optNodes: any, optWeight: any, optCountZeros: any): any;

        function genClustering(G: any, optNodes: any, optWeight: any): any;

        function genSquareClustering(G: any, optNodes: any): any;

        function genTransitivity(G: any): any;

        function genTriangles(G: any, optNodes: any): any;

        function squareClustering(G: any, optNodes: any): any;

        function transitivity(G: any): any;

        function triangles(G: any, optNodes: any): any;

    }

    namespace dag {
        function genIsAperiodic(G: any): any;

        function genIsDirectedAcyclicGraph(G: any): any;

        function genTopologicalSort(G: any, optNbunch: any): any;

        function genTopologicalSortRecursive(G: any, optNbunch: any): any;

        function isAperiodic(_x: any): any;

        function isDirectedAcyclicGraph(G: any): any;

        function topologicalSort(G: any, optNbunch: any): any;

        function topologicalSortRecursive(G: any, optNbunch: any): any;

    }

    namespace eigenvector {
        function eigenvectorCentrality(G: any, ...args: any[]): any;

        function genEigenvectorCentrality(G: any, _maxIter$tolerance$nstart$weight: any): any;

    }

    namespace generic {
        function genHasPath(G: any, _source$target: any): any;

        function genShortestPath(G: any, _source$target$weight: any): any;

        function genShortestPathLength(G: any, _source$target$weight2: any): any;

        function hasPath(G: any, _ref: any): any;

        function shortestPath(G: any, ...args: any[]): any;

        function shortestPathLength(G: any, ...args: any[]): any;

    }

    namespace graphical {
        function genIsGraphical(sequence: any, optMethod: any): any;

        function genIsValidDegreeSequence(sequence: any, optMethod: any): any;

        function genIsValidDegreeSequenceErdosGallai(degreeSequence: any): any;

        function genIsValidDegreeSequenceHavelHakimi(degreeSequence: any): any;

        function isGraphical(sequence: any, ...args: any[]): any;

        function isValidDegreeSequence(sequence: any, optMethod: any): any;

        function isValidDegreeSequenceErdosGallai(degreeSequence: any): any;

        function isValidDegreeSequenceHavelHakimi(degreeSequence: any): any;

    }

    namespace isomorph {
        function couldBeIsomorphic(G1: any, G2: any): any;

        function fastCouldBeIsomorphic(G1: any, G2: any): any;

        function fasterCouldBeIsomorphic(G1: any, G2: any): any;

        function genCouldBeIsomorphic(G1: any, G2: any): any;

        function genFastCouldBeIsomorphic(G1: any, G2: any): any;

        function genFasterCouldBeIsomorphic(G1: any, G2: any): any;

    }

    namespace isomorphism {
        function couldBeIsomorphic(G1: any, G2: any): any;

        function fastCouldBeIsomorphic(G1: any, G2: any): any;

        function fasterCouldBeIsomorphic(G1: any, G2: any): any;

        function genCouldBeIsomorphic(G1: any, G2: any): any;

        function genFastCouldBeIsomorphic(G1: any, G2: any): any;

        function genFasterCouldBeIsomorphic(G1: any, G2: any): any;

        namespace isomorph {
            function couldBeIsomorphic(G1: any, G2: any): any;

            function fastCouldBeIsomorphic(G1: any, G2: any): any;

            function fasterCouldBeIsomorphic(G1: any, G2: any): any;

            function genCouldBeIsomorphic(G1: any, G2: any): any;

            function genFastCouldBeIsomorphic(G1: any, G2: any): any;

            function genFasterCouldBeIsomorphic(G1: any, G2: any): any;

        }

    }

    namespace operators {
        function compose(G: any, H: any): any;

        function difference(G: any, H: any): any;

        function disjointUnion(G: any, H: any): any;

        function genCompose(G: any, H: any): any;

        function genDifference(G: any, H: any): any;

        function genDisjointUnion(G: any, H: any): any;

        function genIntersection(G: any, H: any): any;

        function genSymmetricDifference(G: any, H: any): any;

        function genUnion(G: any, H: any, _rename: any): any;

        function intersection(G: any, H: any): any;

        function symmetricDifference(G: any, H: any): any;

        function union(G: any, H: any, ...args: any[]): any;

        namespace binary {
            function compose(G: any, H: any): any;

            function difference(G: any, H: any): any;

            function disjointUnion(G: any, H: any): any;

            function genCompose(G: any, H: any): any;

            function genDifference(G: any, H: any): any;

            function genDisjointUnion(G: any, H: any): any;

            function genIntersection(G: any, H: any): any;

            function genSymmetricDifference(G: any, H: any): any;

            function genUnion(G: any, H: any, _rename: any): any;

            function intersection(G: any, H: any): any;

            function symmetricDifference(G: any, H: any): any;

            function union(G: any, H: any, ...args: any[]): any;

        }

    }

    namespace shortestPaths {
        function allPairsDijkstraPath(G: any, ...args: any[]): any;

        function allPairsDijkstraPathLength(G: any, ...args: any[]): any;

        function allPairsShortestPath(G: any, optCutoff: any): any;

        function allPairsShortestPathLength(G: any, optCutoff: any): any;

        function bidirectionalShortestPath(G: any, source: any, target: any): any;

        function dijkstraPath(G: any, _ref3: any): any;

        function dijkstraPathLength(G: any, _ref4: any): any;

        function genAllPairsDijkstraPath(G: any, _cutoff$weight2: any): any;

        function genAllPairsDijkstraPathLength(G: any, _cutoff$weight: any): any;

        function genAllPairsShortestPath(G: any, optCutoff: any): any;

        function genAllPairsShortestPathLength(G: any, optCutoff: any): any;

        function genBidirectionalShortestPath(G: any, source: any, target: any): any;

        function genDijkstraPath(G: any, _source$target$weight: any): any;

        function genDijkstraPathLength(G: any, _source$target$weight2: any): any;

        function genHasPath(G: any, _source$target: any): any;

        function genPredecessor(G: any, source: any, optArgs: any): any;

        function genShortestPath(G: any, _source$target$weight: any): any;

        function genShortestPathLength(G: any, _source$target$weight2: any): any;

        function genSingleSourceDijkstra(G: any, _source$target$cutoff$weight: any): any;

        function genSingleSourceDijkstraPath(G: any, _source$cutoff$weight: any): any;

        function genSingleSourceDijkstraPathLength(G: any, _source$cutoff$weight2: any): any;

        function genSingleSourceShortestPath(G: any, source: any, optCutoff: any): any;

        function genSingleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

        function hasPath(G: any, _ref: any): any;

        function predecessor(G: any, source: any, ...args: any[]): any;

        function shortestPath(G: any, ...args: any[]): any;

        function shortestPathLength(G: any, ...args: any[]): any;

        function singleSourceDijkstra(G: any, _ref8: any): any;

        function singleSourceDijkstraPath(G: any, _ref5: any): any;

        function singleSourceDijkstraPathLength(G: any, _ref6: any): any;

        function singleSourceShortestPath(G: any, source: any, optCutoff: any): any;

        function singleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

        namespace generic {
            function genHasPath(G: any, _source$target: any): any;

            function genShortestPath(G: any, _source$target$weight: any): any;

            function genShortestPathLength(G: any, _source$target$weight2: any): any;

            function hasPath(G: any, _ref: any): any;

            function shortestPath(G: any, ...args: any[]): any;

            function shortestPathLength(G: any, ...args: any[]): any;

        }

        namespace unweighted {
            function allPairsShortestPath(G: any, optCutoff: any): any;

            function allPairsShortestPathLength(G: any, optCutoff: any): any;

            function bidirectionalShortestPath(G: any, source: any, target: any): any;

            function genAllPairsShortestPath(G: any, optCutoff: any): any;

            function genAllPairsShortestPathLength(G: any, optCutoff: any): any;

            function genBidirectionalShortestPath(G: any, source: any, target: any): any;

            function genPredecessor(G: any, source: any, optArgs: any): any;

            function genSingleSourceShortestPath(G: any, source: any, optCutoff: any): any;

            function genSingleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

            function predecessor(G: any, source: any, ...args: any[]): any;

            function singleSourceShortestPath(G: any, source: any, optCutoff: any): any;

            function singleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

        }

        namespace weighted {
            function allPairsDijkstraPath(G: any, ...args: any[]): any;

            function allPairsDijkstraPathLength(G: any, ...args: any[]): any;

            function dijkstraPath(G: any, _ref3: any): any;

            function dijkstraPathLength(G: any, _ref4: any): any;

            function genAllPairsDijkstraPath(G: any, _cutoff$weight2: any): any;

            function genAllPairsDijkstraPathLength(G: any, _cutoff$weight: any): any;

            function genDijkstraPath(G: any, _source$target$weight: any): any;

            function genDijkstraPathLength(G: any, _source$target$weight2: any): any;

            function genSingleSourceDijkstra(G: any, _source$target$cutoff$weight: any): any;

            function genSingleSourceDijkstraPath(G: any, _source$cutoff$weight: any): any;

            function genSingleSourceDijkstraPathLength(G: any, _source$cutoff$weight2: any): any;

            function singleSourceDijkstra(G: any, _ref8: any): any;

            function singleSourceDijkstraPath(G: any, _ref5: any): any;

            function singleSourceDijkstraPathLength(G: any, _ref6: any): any;

        }

    }

    namespace unweighted {
        function allPairsShortestPath(G: any, optCutoff: any): any;

        function allPairsShortestPathLength(G: any, optCutoff: any): any;

        function bidirectionalShortestPath(G: any, source: any, target: any): any;

        function genAllPairsShortestPath(G: any, optCutoff: any): any;

        function genAllPairsShortestPathLength(G: any, optCutoff: any): any;

        function genBidirectionalShortestPath(G: any, source: any, target: any): any;

        function genPredecessor(G: any, source: any, optArgs: any): any;

        function genSingleSourceShortestPath(G: any, source: any, optCutoff: any): any;

        function genSingleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

        function predecessor(G: any, source: any, ...args: any[]): any;

        function singleSourceShortestPath(G: any, source: any, optCutoff: any): any;

        function singleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

    }

    namespace weighted {
        function allPairsDijkstraPath(G: any, ...args: any[]): any;

        function allPairsDijkstraPathLength(G: any, ...args: any[]): any;

        function dijkstraPath(G: any, _ref3: any): any;

        function dijkstraPathLength(G: any, _ref4: any): any;

        function genAllPairsDijkstraPath(G: any, _cutoff$weight2: any): any;

        function genAllPairsDijkstraPathLength(G: any, _cutoff$weight: any): any;

        function genDijkstraPath(G: any, _source$target$weight: any): any;

        function genDijkstraPathLength(G: any, _source$target$weight2: any): any;

        function genSingleSourceDijkstra(G: any, _source$target$cutoff$weight: any): any;

        function genSingleSourceDijkstraPath(G: any, _source$cutoff$weight: any): any;

        function genSingleSourceDijkstraPathLength(G: any, _source$cutoff$weight2: any): any;

        function singleSourceDijkstra(G: any, _ref8: any): any;

        function singleSourceDijkstraPath(G: any, _ref5: any): any;

        function singleSourceDijkstraPathLength(G: any, _ref6: any): any;

    }

}

export namespace betweenness {
    function betweennessCentrality(G: any, ...args: any[]): any;

    function edgeBetweennessCentrality(G: any, ...args: any[]): any;

    function genBetweennessCentrality(G: any, optArgDict: any): any;

    function genEdgeBetweennessCentrality(G: any, optArgDict: any): any;

}

export namespace binary {
    function compose(G: any, H: any): any;

    function difference(G: any, H: any): any;

    function disjointUnion(G: any, H: any): any;

    function genCompose(G: any, H: any): any;

    function genDifference(G: any, H: any): any;

    function genDisjointUnion(G: any, H: any): any;

    function genIntersection(G: any, H: any): any;

    function genSymmetricDifference(G: any, H: any): any;

    function genUnion(G: any, H: any, _rename: any): any;

    function intersection(G: any, H: any): any;

    function symmetricDifference(G: any, H: any): any;

    function union(G: any, H: any, ...args: any[]): any;

}

export namespace centrality {
    function betweennessCentrality(G: any, ...args: any[]): any;

    function edgeBetweennessCentrality(G: any, ...args: any[]): any;

    function eigenvectorCentrality(G: any, ...args: any[]): any;

    function genBetweennessCentrality(G: any, optArgDict: any): any;

    function genEdgeBetweennessCentrality(G: any, optArgDict: any): any;

    function genEigenvectorCentrality(G: any, _maxIter$tolerance$nstart$weight: any): any;

    namespace betweenness {
        function betweennessCentrality(G: any, ...args: any[]): any;

        function edgeBetweennessCentrality(G: any, ...args: any[]): any;

        function genBetweennessCentrality(G: any, optArgDict: any): any;

        function genEdgeBetweennessCentrality(G: any, optArgDict: any): any;

    }

    namespace eigenvector {
        function eigenvectorCentrality(G: any, ...args: any[]): any;

        function genEigenvectorCentrality(G: any, _maxIter$tolerance$nstart$weight: any): any;

    }

}

export namespace classes {
    class DiGraph {
        constructor(optData: any, optAttr: any);

        addEdge(u: any, v: any, ...args: any[]): void;

        addEdgesFrom(ebunch: any, ...args: any[]): void;

        addNode(n: any, ...args: any[]): void;

        addNodesFrom(nodes: any, ...args: any[]): void;

        clear(): void;

        degreeIter(optNbunch: any, optWeight: any): any;

        edgesIter(optNbunch: any, ...args: any[]): any;

        hasPredecessor(u: any, v: any): any;

        hasSuccessor(u: any, v: any): any;

        inDegree(optNbunch: any, optWeight: any): any;

        inDegreeIter(optNbunch: any, optWeight: any): any;

        inEdges(optNbunch: any, ...args: any[]): any;

        inEdgesIter(optNbunch: any, ...args: any[]): any;

        isDirected(): any;

        isMultigraph(): any;

        neighbors(n: any): any;

        neighborsIter(n: any): any;

        outDegree(optNbunch: any, optWeight: any): any;

        outDegreeIter(optNbunch: any, optWeight: any): any;

        outEdges(optNbunch: any, optData: any): any;

        outEdgesIter(optNbunch: any, optData: any): any;

        predecessors(n: any): any;

        predecessorsIter(n: any): any;

        removeEdge(u: any, v: any): void;

        removeEdgesFrom(ebunch: any): void;

        removeNode(n: any): void;

        removeNodesFrom(nodes: any): void;

        reverse(...args: any[]): any;

        subgraph(nbunch: any): any;

        successors(n: any): any;

        successorsIter(n: any): any;

        toDirected(): any;

        toUndirected(optReciprocal: any): any;

    }

    class Graph {
        constructor(optData: any, optAttr: any);

        addCycle(nodes: any, optAttr: any): void;

        addEdge(u: any, v: any, optAttrDict: any): void;

        addEdgesFrom(ebunch: any, optAttrDict: any): void;

        addNode(n: any, ...args: any[]): void;

        addNodesFrom(nodes: any, ...args: any[]): void;

        addPath(nodes: any, optAttr: any): void;

        addStar(nodes: any, optAttr: any): any;

        addWeightedEdgesFrom(ebunch: any, optWeight: any, optAttr: any): any;

        adjacencyIter(): any;

        adjacencyList(): any;

        clear(): void;

        copy(): any;

        degree(optNbunch: any, optWeight: any): any;

        degreeIter(optNbunch: any, optWeight: any): any;

        edges(optNbunch: any, ...args: any[]): any;

        edgesIter(optNbunch: any, ...args: any[]): any;

        get(n: any): any;

        getEdgeData(u: any, v: any, ...args: any[]): any;

        hasEdge(u: any, v: any): any;

        hasNode(n: any): any;

        isDirected(): any;

        isMultigraph(): any;

        nbunchIter(optNbunch: any): any;

        neighbors(n: any): any;

        neighborsIter(n: any): any;

        nodes(...args: any[]): any;

        nodesIter(...args: any[]): any;

        nodesWithSelfloops(): any;

        numberOfEdges(u: any, v: any): any;

        numberOfNodes(): any;

        numberOfSelfloops(): any;

        order(): any;

        removeEdge(u: any, v: any): void;

        removeEdgesFrom(ebunch: any): void;

        removeNode(n: any): any;

        removeNodesFrom(nodes: any): any;

        selfloopEdges(...args: any[]): any;

        size(optWeight: any): any;

        subgraph(nbunch: any): any;

        toDirected(): any;

        toString(): any;

        toUndirected(): any;

    }

    class MultiDiGraph {
        constructor(optData: any, optAttr: any);

        addEdge(u: any, v: any, optKey: any, optAttrDict: any): void;

        addEdgesFrom(ebunch: any, optAttrDict: any): void;

        degreeIter(optNbunch: any, optWeight: any): any;

        edges(optNbunch: any, optData: any, optKeys: any): any;

        edgesIter(optNbunch: any, ...args: any[]): any;

        getEdgeData(u: any, v: any, optKey: any, optDefault: any): any;

        hasEdge(u: any, v: any, optKey: any): any;

        inDegreeIter(optNbunch: any, optWeight: any): any;

        inEdges(optNbunch: any, optData: any, optKeys: any): any;

        inEdgesIter(optNbunch: any, ...args: any[]): any;

        isDirected(): any;

        isMultigraph(): any;

        numberOfEdges(optU: any, optV: any): any;

        outDegreeIter(optNbunch: any, optWeight: any): any;

        outEdges(optNbunch: any, optData: any, optKeys: any): any;

        outEdgesIter(optNbunch: any, optData: any, optKeys: any): any;

        removeEdge(u: any, v: any, optKey: any): void;

        removeEdgesFrom(ebunch: any): void;

        reverse(...args: any[]): any;

        selfloopEdges(...args: any[]): any;

        subgraph(nBunch: any): any;

        toDirected(): any;

        toUndirected(optReciprocal: any): any;

    }

    class MultiGraph {
        constructor(optData: any, optAttr: any);

        addEdge(u: any, v: any, optKey: any, optAttrDict: any): void;

        addEdgesFrom(ebunch: any, optAttrDict: any): void;

        degreeIter(optNbunch: any, optWeight: any): any;

        edges(optNbunch: any, optData: any, optKeys: any): any;

        edgesIter(optNbunch: any, ...args: any[]): any;

        getEdgeData(u: any, v: any, optKey: any, optDefault: any): any;

        hasEdge(u: any, v: any, optKey: any): any;

        isDirected(): any;

        isMultigraph(): any;

        numberOfEdges(optU: any, optV: any): any;

        removeEdge(u: any, v: any, optKey: any): void;

        removeEdgesFrom(ebunch: any): void;

        selfloopEdges(...args: any[]): any;

        subgraph(nbunch: any): any;

        toDirected(): any;

    }

    function createEmptyCopy(G: any, ...args: any[]): any;

    function degree(G: any, optNbunch: any, optWeight: any): any;

    function degreeHistogram(G: any): any;

    function density(G: any): any;

    function edges(G: any, optNbunch: any): any;

    function edgesIter(G: any, optNbunch: any): any;

    function freeze(G: any): any;

    function getEdgeAttributes(G: any, name: any): any;

    function getNodeAttributes(G: any, name: any): any;

    function info(G: any, optN: any): any;

    function isDirected(G: any): any;

    function isFrozen(G: any): any;

    function neighbors(G: any, n: any): any;

    function nodes(G: any): any;

    function nodesIter(G: any): any;

    function numberOfEdges(G: any): any;

    function numberOfNodes(G: any): any;

    function setEdgeAttributes(G: any, name: any, attributes: any): void;

    function setNodeAttributes(G: any, name: any, attributes: any): any;

    function subgraph(G: any, nbunch: any): any;

    namespace functions {
        function createEmptyCopy(G: any, ...args: any[]): any;

        function degree(G: any, optNbunch: any, optWeight: any): any;

        function degreeHistogram(G: any): any;

        function density(G: any): any;

        function edges(G: any, optNbunch: any): any;

        function edgesIter(G: any, optNbunch: any): any;

        function freeze(G: any): any;

        function getEdgeAttributes(G: any, name: any): any;

        function getNodeAttributes(G: any, name: any): any;

        function info(G: any, optN: any): any;

        function isDirected(G: any): any;

        function isFrozen(G: any): any;

        function neighbors(G: any, n: any): any;

        function nodes(G: any): any;

        function nodesIter(G: any): any;

        function numberOfEdges(G: any): any;

        function numberOfNodes(G: any): any;

        function setEdgeAttributes(G: any, name: any, attributes: any): void;

        function setNodeAttributes(G: any, name: any, attributes: any): any;

        function subgraph(G: any, nbunch: any): any;

    }

}

export namespace classic {
    function balancedTree(r: any, h: any, optCreateUsing: any): any;

    function completeGraph(n: any, optCreateUsing: any): any;

    function cycleGraph(n: any, optCreateUsing: any): any;

    function emptyGraph(optN: any, optCreateUsing: any): any;

    function fullRaryTree(r: any, n: any, optCreateUsing: any): any;

    function grid2dGraph(rows: any, columns: any, ...args: any[]): any;

    function nullGraph(optCreateUsing: any): any;

    function pathGraph(n: any, optCreateUsing: any): any;

    function trivialGraph(optCreateUsing: any): any;

}

export namespace clique {
    function findCliques(G: any): any;

    function findCliquesRecursive(G: any): any;

    function genFindCliques(G: any): any;

    function genFindCliquesRecursive(G: any): any;

    function genGraphCliqueNumber(G: any, optCliques: any): any;

    function genGraphNumberOfCliques(G: any, optCliques: any): any;

    function genNumberOfCliques(G: any, optNodes: any, optCliques: any): any;

    function graphCliqueNumber(G: any, optCliques: any): any;

    function graphNumberOfCliques(G: any, optCliques: any): any;

    function numberOfCliques(G: any, optNodes: any, optCliques: any): any;

}

export namespace cluster {
    function averageClustering(G: any, optNodes: any, optWeight: any, ...args: any[]): any;

    function clustering(G: any, optNodes: any, optWeight: any): any;

    function genAverageClustering(G: any, optNodes: any, optWeight: any, optCountZeros: any): any;

    function genClustering(G: any, optNodes: any, optWeight: any): any;

    function genSquareClustering(G: any, optNodes: any): any;

    function genTransitivity(G: any): any;

    function genTriangles(G: any, optNodes: any): any;

    function squareClustering(G: any, optNodes: any): any;

    function transitivity(G: any): any;

    function triangles(G: any, optNodes: any): any;

}

export namespace convert {
    function convertToDirected(G: any): any;

    function convertToUndirected(G: any): any;

    function fromDictOfDicts(d: any, optCreateUsing: any, ...args: any[]): any;

    function fromDictOfLists(d: any, optCreateUsing: any): any;

    function fromEdgelist(edgelist: any, optCreateUsing: any): any;

    function toDictOfDicts(G: any, optNodelist: any, optEdgeData: any): any;

    function toDictOfLists(G: any, optNodelist: any): any;

    function toEdgelist(G: any, optNodelist: any): any;

    function toNetworkxGraph(data: any, optCreateUsing: any, ...args: any[]): any;

}

export namespace dag {
    function genIsAperiodic(G: any): any;

    function genIsDirectedAcyclicGraph(G: any): any;

    function genTopologicalSort(G: any, optNbunch: any): any;

    function genTopologicalSortRecursive(G: any, optNbunch: any): any;

    function isAperiodic(_x: any): any;

    function isDirectedAcyclicGraph(G: any): any;

    function topologicalSort(G: any, optNbunch: any): any;

    function topologicalSortRecursive(G: any, optNbunch: any): any;

}

export namespace degreeSequence {
    function genHavelHakimiGraph(degreeSequence: any, optCreateUsing: any): any;

    function havelHakimiGraph(degreeSequence: any, optCreateUsing: any): any;

}

export namespace drawing {
    const svg: any;

    function draw(G: any, config: any, optBind: any): any;

}

export namespace eigenvector {
    function eigenvectorCentrality(G: any, ...args: any[]): any;

    function genEigenvectorCentrality(G: any, _maxIter$tolerance$nstart$weight: any): any;

}

export namespace exceptions {
    function JSNetworkXAlgorithmError(message: any): void;

    function JSNetworkXError(message: any): void;

    function JSNetworkXException(message: any): void;

    function JSNetworkXNoPath(message: any): void;

    function JSNetworkXUnfeasible(message: any): void;

    function KeyError(message: any): void;

    namespace KeyError {
        const stackTraceLimit: number;

        function captureStackTrace(p0: any, p1: any): any;

    }

}

export namespace functions {
    function createEmptyCopy(G: any, ...args: any[]): any;

    function degree(G: any, optNbunch: any, optWeight: any): any;

    function degreeHistogram(G: any): any;

    function density(G: any): any;

    function edges(G: any, optNbunch: any): any;

    function edgesIter(G: any, optNbunch: any): any;

    function freeze(G: any): any;

    function getEdgeAttributes(G: any, name: any): any;

    function getNodeAttributes(G: any, name: any): any;

    function info(G: any, optN: any): any;

    function isDirected(G: any): any;

    function isFrozen(G: any): any;

    function neighbors(G: any, n: any): any;

    function nodes(G: any): any;

    function nodesIter(G: any): any;

    function numberOfEdges(G: any): any;

    function numberOfNodes(G: any): any;

    function setEdgeAttributes(G: any, name: any, attributes: any): void;

    function setNodeAttributes(G: any, name: any, attributes: any): any;

    function subgraph(G: any, nbunch: any): any;

}

export namespace generators {
    function balancedTree(r: any, h: any, optCreateUsing: any): any;

    function binomialGraph(n: any, p: any, optDirected: any): any;

    function bullGraph(optCreateUsing: any): any;

    function completeGraph(n: any, optCreateUsing: any): any;

    function cycleGraph(n: any, optCreateUsing: any): any;

    function davisSouthernWomenGraph(): any;

    function emptyGraph(optN: any, optCreateUsing: any): any;

    function erdosRenyiGraph(n: any, p: any, optDirected: any): any;

    function fastGnpRandomGraph(n: any, p: any, ...args: any[]): any;

    function florentineFamiliesGraph(): any;

    function fullRaryTree(r: any, n: any, optCreateUsing: any): any;

    function genBinomialGraph(n: any, p: any, optDirected: any): any;

    function genErdosRenyiGraph(n: any, p: any, optDirected: any): any;

    function genFastGnpRandomGraph(n: any, p: any, optDirected: any): any;

    function genGnpRandomGraph(n: any, p: any, optDirected: any): any;

    function genHavelHakimiGraph(degreeSequence: any, optCreateUsing: any): any;

    function gnpRandomGraph(n: any, p: any, ...args: any[]): any;

    function grid2dGraph(rows: any, columns: any, ...args: any[]): any;

    function havelHakimiGraph(degreeSequence: any, optCreateUsing: any): any;

    function karateClubGraph(): any;

    function krackhardtKiteGraph(optCreateUsing: any): any;

    function makeSmallGraph(_ref: any, optCreateUsing: any): any;

    function makeSmallUndirectedGraph(graphDescription: any, optCreateUsing: any): any;

    function nullGraph(optCreateUsing: any): any;

    function pathGraph(n: any, optCreateUsing: any): any;

    function trivialGraph(optCreateUsing: any): any;

    namespace classic {
        function balancedTree(r: any, h: any, optCreateUsing: any): any;

        function completeGraph(n: any, optCreateUsing: any): any;

        function cycleGraph(n: any, optCreateUsing: any): any;

        function emptyGraph(optN: any, optCreateUsing: any): any;

        function fullRaryTree(r: any, n: any, optCreateUsing: any): any;

        function grid2dGraph(rows: any, columns: any, ...args: any[]): any;

        function nullGraph(optCreateUsing: any): any;

        function pathGraph(n: any, optCreateUsing: any): any;

        function trivialGraph(optCreateUsing: any): any;

    }

    namespace degreeSequence {
        function genHavelHakimiGraph(degreeSequence: any, optCreateUsing: any): any;

        function havelHakimiGraph(degreeSequence: any, optCreateUsing: any): any;

    }

    namespace randomGraphs {
        function binomialGraph(n: any, p: any, optDirected: any): any;

        function erdosRenyiGraph(n: any, p: any, optDirected: any): any;

        function fastGnpRandomGraph(n: any, p: any, ...args: any[]): any;

        function genBinomialGraph(n: any, p: any, optDirected: any): any;

        function genErdosRenyiGraph(n: any, p: any, optDirected: any): any;

        function genFastGnpRandomGraph(n: any, p: any, optDirected: any): any;

        function genGnpRandomGraph(n: any, p: any, optDirected: any): any;

        function gnpRandomGraph(n: any, p: any, ...args: any[]): any;

    }

    namespace small {
        function bullGraph(optCreateUsing: any): any;

        function krackhardtKiteGraph(optCreateUsing: any): any;

        function makeSmallGraph(_ref: any, optCreateUsing: any): any;

        function makeSmallUndirectedGraph(graphDescription: any, optCreateUsing: any): any;

    }

    namespace social {
        function davisSouthernWomenGraph(): any;

        function florentineFamiliesGraph(): any;

        function karateClubGraph(): any;

    }

}

export namespace generic {
    function genHasPath(G: any, _source$target: any): any;

    function genShortestPath(G: any, _source$target$weight: any): any;

    function genShortestPathLength(G: any, _source$target$weight2: any): any;

    function hasPath(G: any, _ref: any): any;

    function shortestPath(G: any, ...args: any[]): any;

    function shortestPathLength(G: any, ...args: any[]): any;

}

export namespace graphical {
    function genIsGraphical(sequence: any, optMethod: any): any;

    function genIsValidDegreeSequence(sequence: any, optMethod: any): any;

    function genIsValidDegreeSequenceErdosGallai(degreeSequence: any): any;

    function genIsValidDegreeSequenceHavelHakimi(degreeSequence: any): any;

    function isGraphical(sequence: any, ...args: any[]): any;

    function isValidDegreeSequence(sequence: any, optMethod: any): any;

    function isValidDegreeSequenceErdosGallai(degreeSequence: any): any;

    function isValidDegreeSequenceHavelHakimi(degreeSequence: any): any;

}

export namespace isomorph {
    function couldBeIsomorphic(G1: any, G2: any): any;

    function fastCouldBeIsomorphic(G1: any, G2: any): any;

    function fasterCouldBeIsomorphic(G1: any, G2: any): any;

    function genCouldBeIsomorphic(G1: any, G2: any): any;

    function genFastCouldBeIsomorphic(G1: any, G2: any): any;

    function genFasterCouldBeIsomorphic(G1: any, G2: any): any;

}

export namespace isomorphism {
    function couldBeIsomorphic(G1: any, G2: any): any;

    function fastCouldBeIsomorphic(G1: any, G2: any): any;

    function fasterCouldBeIsomorphic(G1: any, G2: any): any;

    function genCouldBeIsomorphic(G1: any, G2: any): any;

    function genFastCouldBeIsomorphic(G1: any, G2: any): any;

    function genFasterCouldBeIsomorphic(G1: any, G2: any): any;

    namespace isomorph {
        function couldBeIsomorphic(G1: any, G2: any): any;

        function fastCouldBeIsomorphic(G1: any, G2: any): any;

        function fasterCouldBeIsomorphic(G1: any, G2: any): any;

        function genCouldBeIsomorphic(G1: any, G2: any): any;

        function genFastCouldBeIsomorphic(G1: any, G2: any): any;

        function genFasterCouldBeIsomorphic(G1: any, G2: any): any;

    }

}

export namespace operators {
    function compose(G: any, H: any): any;

    function difference(G: any, H: any): any;

    function disjointUnion(G: any, H: any): any;

    function genCompose(G: any, H: any): any;

    function genDifference(G: any, H: any): any;

    function genDisjointUnion(G: any, H: any): any;

    function genIntersection(G: any, H: any): any;

    function genSymmetricDifference(G: any, H: any): any;

    function genUnion(G: any, H: any, _rename: any): any;

    function intersection(G: any, H: any): any;

    function symmetricDifference(G: any, H: any): any;

    function union(G: any, H: any, ...args: any[]): any;

    namespace binary {
        function compose(G: any, H: any): any;

        function difference(G: any, H: any): any;

        function disjointUnion(G: any, H: any): any;

        function genCompose(G: any, H: any): any;

        function genDifference(G: any, H: any): any;

        function genDisjointUnion(G: any, H: any): any;

        function genIntersection(G: any, H: any): any;

        function genSymmetricDifference(G: any, H: any): any;

        function genUnion(G: any, H: any, _rename: any): any;

        function intersection(G: any, H: any): any;

        function symmetricDifference(G: any, H: any): any;

        function union(G: any, H: any, ...args: any[]): any;

    }

}

export namespace randomGraphs {
    function binomialGraph(n: any, p: any, optDirected: any): any;

    function erdosRenyiGraph(n: any, p: any, optDirected: any): any;

    function fastGnpRandomGraph(n: any, p: any, ...args: any[]): any;

    function genBinomialGraph(n: any, p: any, optDirected: any): any;

    function genErdosRenyiGraph(n: any, p: any, optDirected: any): any;

    function genFastGnpRandomGraph(n: any, p: any, optDirected: any): any;

    function genGnpRandomGraph(n: any, p: any, optDirected: any): any;

    function gnpRandomGraph(n: any, p: any, ...args: any[]): any;

}

export namespace relabel {
    function convertNodeLabelsToIntegers(G: any, ...args: any[]): any;

    function relabelNodes(G: any, mapping: any, ...args: any[]): any;

}

export namespace shortestPaths {
    function allPairsDijkstraPath(G: any, ...args: any[]): any;

    function allPairsDijkstraPathLength(G: any, ...args: any[]): any;

    function allPairsShortestPath(G: any, optCutoff: any): any;

    function allPairsShortestPathLength(G: any, optCutoff: any): any;

    function bidirectionalShortestPath(G: any, source: any, target: any): any;

    function dijkstraPath(G: any, _ref3: any): any;

    function dijkstraPathLength(G: any, _ref4: any): any;

    function genAllPairsDijkstraPath(G: any, _cutoff$weight2: any): any;

    function genAllPairsDijkstraPathLength(G: any, _cutoff$weight: any): any;

    function genAllPairsShortestPath(G: any, optCutoff: any): any;

    function genAllPairsShortestPathLength(G: any, optCutoff: any): any;

    function genBidirectionalShortestPath(G: any, source: any, target: any): any;

    function genDijkstraPath(G: any, _source$target$weight: any): any;

    function genDijkstraPathLength(G: any, _source$target$weight2: any): any;

    function genHasPath(G: any, _source$target: any): any;

    function genPredecessor(G: any, source: any, optArgs: any): any;

    function genShortestPath(G: any, _source$target$weight: any): any;

    function genShortestPathLength(G: any, _source$target$weight2: any): any;

    function genSingleSourceDijkstra(G: any, _source$target$cutoff$weight: any): any;

    function genSingleSourceDijkstraPath(G: any, _source$cutoff$weight: any): any;

    function genSingleSourceDijkstraPathLength(G: any, _source$cutoff$weight2: any): any;

    function genSingleSourceShortestPath(G: any, source: any, optCutoff: any): any;

    function genSingleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

    function hasPath(G: any, _ref: any): any;

    function predecessor(G: any, source: any, ...args: any[]): any;

    function shortestPath(G: any, ...args: any[]): any;

    function shortestPathLength(G: any, ...args: any[]): any;

    function singleSourceDijkstra(G: any, _ref8: any): any;

    function singleSourceDijkstraPath(G: any, _ref5: any): any;

    function singleSourceDijkstraPathLength(G: any, _ref6: any): any;

    function singleSourceShortestPath(G: any, source: any, optCutoff: any): any;

    function singleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

    namespace generic {
        function genHasPath(G: any, _source$target: any): any;

        function genShortestPath(G: any, _source$target$weight: any): any;

        function genShortestPathLength(G: any, _source$target$weight2: any): any;

        function hasPath(G: any, _ref: any): any;

        function shortestPath(G: any, ...args: any[]): any;

        function shortestPathLength(G: any, ...args: any[]): any;

    }

    namespace unweighted {
        function allPairsShortestPath(G: any, optCutoff: any): any;

        function allPairsShortestPathLength(G: any, optCutoff: any): any;

        function bidirectionalShortestPath(G: any, source: any, target: any): any;

        function genAllPairsShortestPath(G: any, optCutoff: any): any;

        function genAllPairsShortestPathLength(G: any, optCutoff: any): any;

        function genBidirectionalShortestPath(G: any, source: any, target: any): any;

        function genPredecessor(G: any, source: any, optArgs: any): any;

        function genSingleSourceShortestPath(G: any, source: any, optCutoff: any): any;

        function genSingleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

        function predecessor(G: any, source: any, ...args: any[]): any;

        function singleSourceShortestPath(G: any, source: any, optCutoff: any): any;

        function singleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

    }

    namespace weighted {
        function allPairsDijkstraPath(G: any, ...args: any[]): any;

        function allPairsDijkstraPathLength(G: any, ...args: any[]): any;

        function dijkstraPath(G: any, _ref3: any): any;

        function dijkstraPathLength(G: any, _ref4: any): any;

        function genAllPairsDijkstraPath(G: any, _cutoff$weight2: any): any;

        function genAllPairsDijkstraPathLength(G: any, _cutoff$weight: any): any;

        function genDijkstraPath(G: any, _source$target$weight: any): any;

        function genDijkstraPathLength(G: any, _source$target$weight2: any): any;

        function genSingleSourceDijkstra(G: any, _source$target$cutoff$weight: any): any;

        function genSingleSourceDijkstraPath(G: any, _source$cutoff$weight: any): any;

        function genSingleSourceDijkstraPathLength(G: any, _source$cutoff$weight2: any): any;

        function singleSourceDijkstra(G: any, _ref8: any): any;

        function singleSourceDijkstraPath(G: any, _ref5: any): any;

        function singleSourceDijkstraPathLength(G: any, _ref6: any): any;

    }

}

export namespace small {
    function bullGraph(optCreateUsing: any): any;

    function krackhardtKiteGraph(optCreateUsing: any): any;

    function makeSmallGraph(_ref: any, optCreateUsing: any): any;

    function makeSmallUndirectedGraph(graphDescription: any, optCreateUsing: any): any;

}

export namespace social {
    function davisSouthernWomenGraph(): any;

    function florentineFamiliesGraph(): any;

    function karateClubGraph(): any;

}

export namespace unweighted {
    function allPairsShortestPath(G: any, optCutoff: any): any;

    function allPairsShortestPathLength(G: any, optCutoff: any): any;

    function bidirectionalShortestPath(G: any, source: any, target: any): any;

    function genAllPairsShortestPath(G: any, optCutoff: any): any;

    function genAllPairsShortestPathLength(G: any, optCutoff: any): any;

    function genBidirectionalShortestPath(G: any, source: any, target: any): any;

    function genPredecessor(G: any, source: any, optArgs: any): any;

    function genSingleSourceShortestPath(G: any, source: any, optCutoff: any): any;

    function genSingleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

    function predecessor(G: any, source: any, ...args: any[]): any;

    function singleSourceShortestPath(G: any, source: any, optCutoff: any): any;

    function singleSourceShortestPathLength(G: any, source: any, optCutoff: any): any;

}

export namespace weighted {
    function allPairsDijkstraPath(G: any, ...args: any[]): any;

    function allPairsDijkstraPathLength(G: any, ...args: any[]): any;

    function dijkstraPath(G: any, _ref3: any): any;

    function dijkstraPathLength(G: any, _ref4: any): any;

    function genAllPairsDijkstraPath(G: any, _cutoff$weight2: any): any;

    function genAllPairsDijkstraPathLength(G: any, _cutoff$weight: any): any;

    function genDijkstraPath(G: any, _source$target$weight: any): any;

    function genDijkstraPathLength(G: any, _source$target$weight2: any): any;

    function genSingleSourceDijkstra(G: any, _source$target$cutoff$weight: any): any;

    function genSingleSourceDijkstraPath(G: any, _source$cutoff$weight: any): any;

    function genSingleSourceDijkstraPathLength(G: any, _source$cutoff$weight2: any): any;

    function singleSourceDijkstra(G: any, _ref8: any): any;

    function singleSourceDijkstraPath(G: any, _ref5: any): any;

    function singleSourceDijkstraPathLength(G: any, _ref6: any): any;

}

